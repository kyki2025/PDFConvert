<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ–‡ä»¶æ ¼å¼è½¬æ¢å·¥å…·</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ“„</text></svg>">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>æ–‡ä»¶æ ¼å¼è½¬æ¢å·¥å…·</h1>
            <p>æ”¯æŒæ–‡ä»¶ä¸PDFæ ¼å¼çš„åŒå‘è½¬æ¢</p>
        </header>

        <main>
            <!-- è½¬æ¢æ¨¡å¼é€‰æ‹© -->
            <div class="mode-selection">
                <div class="mode-tabs">
                    <button class="mode-tab active" id="toPdfTab">æ–‡ä»¶è½¬PDF</button>
                    <button class="mode-tab" id="fromPdfTab">PDFè½¬æ–‡ä»¶</button>
                </div>
            </div>

            <!-- æ–‡ä»¶è½¬PDFæ¨¡å¼ -->
            <div class="conversion-mode" id="toPdfMode">
                <div class="upload-section">
                    <div class="upload-area" id="uploadArea">
                        <div class="upload-icon">ğŸ“</div>
                        <h3>æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</h3>
                        <p>æ”¯æŒçš„æ ¼å¼ï¼šTXTã€DOCXã€XLSXã€XLSã€JPGã€PNGã€GIFã€BMP</p>
                        <p style="font-size: 0.8em; color: #888;">æ³¨æ„ï¼šDOCæ ¼å¼æ”¯æŒæœ‰é™ï¼Œå»ºè®®ä½¿ç”¨DOCXæ ¼å¼</p>
                        <input type="file" id="fileInput" multiple accept=".txt,.doc,.docx,.xlsx,.xls,.jpg,.jpeg,.png,.gif,.bmp" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer;">
                    </div>
                </div>

                <div class="file-list" id="fileList">
                    <h3>å·²é€‰æ‹©çš„æ–‡ä»¶</h3>
                    <div id="selectedFiles"></div>
                </div>

                <div class="controls">
                    <button id="convertBtn" class="convert-btn" disabled>è½¬æ¢ä¸ºPDF</button>
                    <button id="clearBtn" class="clear-btn">æ¸…ç©ºæ–‡ä»¶</button>
                </div>
            </div>

            <!-- PDFè½¬æ–‡ä»¶æ¨¡å¼ -->
            <div class="conversion-mode" id="fromPdfMode" style="display: none;">
                <div class="upload-section">
                    <div class="upload-area" id="pdfUploadArea">
                        <div class="upload-icon">ğŸ“„</div>
                        <h3>æ‹–æ‹½PDFæ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</h3>
                        <p>æ”¯æŒPDFæ ¼å¼æ–‡ä»¶</p>
                        <input type="file" id="pdfFileInput" accept=".pdf" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer;">
                    </div>
                </div>

                <div class="pdf-file-info" id="pdfFileInfo" style="display: none;">
                    <h3>PDFæ–‡ä»¶ä¿¡æ¯</h3>
                    <div id="pdfDetails"></div>
                </div>

                <div class="conversion-options" id="conversionOptions" style="display: none;">
                    <h3>é€‰æ‹©è½¬æ¢æ ¼å¼</h3>
                    <div class="format-options">
                        <button class="format-btn" data-format="txt">
                            <span class="format-icon">ğŸ“„</span>
                            <span class="format-name">æ–‡æœ¬æ–‡ä»¶ (TXT)</span>
                        </button>
                        <button class="format-btn" data-format="docx">
                            <span class="format-icon">ğŸ“˜</span>
                            <span class="format-name">Wordæ–‡æ¡£ (DOCX)</span>
                        </button>
                        <button class="format-btn" data-format="xlsx">
                            <span class="format-icon">ğŸ“Š</span>
                            <span class="format-name">Excelè¡¨æ ¼ (XLSX)</span>
                        </button>
                        <button class="format-btn" data-format="png">
                            <span class="format-icon">ğŸ–¼ï¸</span>
                            <span class="format-name">PNGå›¾ç‰‡</span>
                        </button>
                        <button class="format-btn" data-format="jpg">
                            <span class="format-icon">ğŸ–¼ï¸</span>
                            <span class="format-name">JPGå›¾ç‰‡</span>
                        </button>
                    </div>
                </div>

                <div class="controls" id="pdfControls" style="display: none;">
                    <button id="convertFromPdfBtn" class="convert-btn" disabled>å¼€å§‹è½¬æ¢</button>
                    <button id="clearPdfBtn" class="clear-btn">æ¸…ç©ºæ–‡ä»¶</button>
                </div>
            </div>

            <div class="preview-section" id="previewSection" style="display: none;">
                <h3>é¢„è§ˆ</h3>
                <div id="previewContent"></div>
            </div>
        </main>
    </div>

    <script>
        // ç®€åŒ–çš„æ–‡ä»¶è½¬æ¢å™¨ - ä¸“é—¨è§£å†³æ–‡ä»¶é€‰æ‹©é—®é¢˜
        class SimpleFileConverter {
            constructor() {
                this.selectedFiles = [];
                this.selectedPdfFile = null;
                this.selectedFormat = null;
                this.init();
            }

            init() {
                console.log('ğŸš€ åˆå§‹åŒ–æ–‡ä»¶è½¬æ¢å™¨...');
                
                // ç­‰å¾…DOMå®Œå…¨åŠ è½½
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => this.setupAll());
                } else {
                    this.setupAll();
                }
            }

            setupAll() {
                console.log('ğŸ“‹ è®¾ç½®æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨...');
                
                // è®¾ç½®æ¨¡å¼åˆ‡æ¢
                this.setupModeSwitch();
                
                // è®¾ç½®æ–‡ä»¶è½¬PDF
                this.setupFileToPdf();
                
                // è®¾ç½®PDFè½¬æ–‡ä»¶
                this.setupPdfToFile();
                
                console.log('âœ… æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨è®¾ç½®å®Œæˆ');
            }

            setupModeSwitch() {
                const toPdfTab = document.getElementById('toPdfTab');
                const fromPdfTab = document.getElementById('fromPdfTab');
                const toPdfMode = document.getElementById('toPdfMode');
                const fromPdfMode = document.getElementById('fromPdfMode');

                if (toPdfTab && fromPdfTab) {
                    toPdfTab.onclick = () => {
                        toPdfTab.classList.add('active');
                        fromPdfTab.classList.remove('active');
                        if (toPdfMode) toPdfMode.style.display = 'block';
                        if (fromPdfMode) fromPdfMode.style.display = 'none';
                        console.log('ğŸ”„ åˆ‡æ¢åˆ°æ–‡ä»¶è½¬PDFæ¨¡å¼');
                    };

                    fromPdfTab.onclick = () => {
                        fromPdfTab.classList.add('active');
                        toPdfTab.classList.remove('active');
                        if (fromPdfMode) fromPdfMode.style.display = 'block';
                        if (toPdfMode) toPdfMode.style.display = 'none';
                        console.log('ğŸ”„ åˆ‡æ¢åˆ°PDFè½¬æ–‡ä»¶æ¨¡å¼');
                    };
                }
            }

            setupFileToPdf() {
                const fileInput = document.getElementById('fileInput');
                const uploadArea = document.getElementById('uploadArea');
                const convertBtn = document.getElementById('convertBtn');
                const clearBtn = document.getElementById('clearBtn');

                console.log('ğŸ“ è®¾ç½®æ–‡ä»¶è½¬PDFäº‹ä»¶...');
                console.log('- fileInput:', !!fileInput);
                console.log('- uploadArea:', !!uploadArea);

                if (fileInput) {
                    // ç›´æ¥ç»‘å®šæ–‡ä»¶è¾“å…¥å˜åŒ–äº‹ä»¶
                    fileInput.onchange = (e) => {
                        console.log('ğŸ“ æ–‡ä»¶é€‰æ‹©å˜åŒ–:', e.target.files.length, 'ä¸ªæ–‡ä»¶');
                        this.handleFiles(e.target.files);
                    };
                    
                    // ç¡®ä¿æ–‡ä»¶è¾“å…¥å¯ä»¥è¢«ç‚¹å‡»
                    fileInput.style.pointerEvents = 'auto';
                    fileInput.style.zIndex = '10';
                    
                    console.log('âœ… æ–‡ä»¶è¾“å…¥äº‹ä»¶ç»‘å®šå®Œæˆ');
                }

                if (uploadArea) {
                    // æ‹–æ‹½äº‹ä»¶
                    uploadArea.ondragover = (e) => {
                        e.preventDefault();
                        uploadArea.classList.add('dragover');
                    };
                    
                    uploadArea.ondragleave = (e) => {
                        e.preventDefault();
                        uploadArea.classList.remove('dragover');
                    };
                    
                    uploadArea.ondrop = (e) => {
                        e.preventDefault();
                        uploadArea.classList.remove('dragover');
                        console.log('ğŸ“ æ‹–æ‹½æ–‡ä»¶:', e.dataTransfer.files.length, 'ä¸ª');
                        this.handleFiles(e.dataTransfer.files);
                    };
                }

                if (convertBtn) {
                    convertBtn.onclick = () => this.convertToPdf();
                }

                if (clearBtn) {
                    clearBtn.onclick = () => this.clearFiles();
                }
            }

            setupPdfToFile() {
                const pdfFileInput = document.getElementById('pdfFileInput');
                const pdfUploadArea = document.getElementById('pdfUploadArea');
                const convertFromPdfBtn = document.getElementById('convertFromPdfBtn');
                const clearPdfBtn = document.getElementById('clearPdfBtn');

                console.log('ğŸ“„ è®¾ç½®PDFè½¬æ–‡ä»¶äº‹ä»¶...');
                console.log('- pdfFileInput:', !!pdfFileInput);
                console.log('- pdfUploadArea:', !!pdfUploadArea);

                if (pdfFileInput) {
                    pdfFileInput.onchange = (e) => {
                        console.log('ğŸ“„ PDFæ–‡ä»¶é€‰æ‹©å˜åŒ–');
                        if (e.target.files.length > 0) {
                            this.handlePdfFile(e.target.files[0]);
                        }
                    };
                    
                    // ç¡®ä¿PDFæ–‡ä»¶è¾“å…¥å¯ä»¥è¢«ç‚¹å‡»
                    pdfFileInput.style.pointerEvents = 'auto';
                    pdfFileInput.style.zIndex = '10';
                }

                if (pdfUploadArea) {
                    pdfUploadArea.ondragover = (e) => {
                        e.preventDefault();
                        pdfUploadArea.classList.add('dragover');
                    };
                    
                    pdfUploadArea.ondragleave = (e) => {
                        e.preventDefault();
                        pdfUploadArea.classList.remove('dragover');
                    };
                    
                    pdfUploadArea.ondrop = (e) => {
                        e.preventDefault();
                        pdfUploadArea.classList.remove('dragover');
                        if (e.dataTransfer.files.length > 0) {
                            this.handlePdfFile(e.dataTransfer.files[0]);
                        }
                    };
                }

                // æ ¼å¼é€‰æ‹©æŒ‰é’®
                const formatBtns = document.querySelectorAll('.format-btn');
                formatBtns.forEach(btn => {
                    btn.onclick = () => {
                        formatBtns.forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        this.selectedFormat = btn.getAttribute('data-format');
                        this.updatePdfConvertButton();
                        console.log('ğŸ¯ é€‰æ‹©æ ¼å¼:', this.selectedFormat);
                    };
                });

                if (convertFromPdfBtn) {
                    convertFromPdfBtn.onclick = () => this.convertPdfToFile();
                }

                if (clearPdfBtn) {
                    clearPdfBtn.onclick = () => this.clearPdfFile();
                }
            }

            handleFiles(files) {
                console.log('ğŸ“ å¤„ç†æ–‡ä»¶:', files.length, 'ä¸ª');
                this.selectedFiles = Array.from(files);
                this.displaySelectedFiles();
                this.updateConvertButton();
            }

            handlePdfFile(file) {
                console.log('ğŸ“„ å¤„ç†PDFæ–‡ä»¶:', file.name);
                if (file && file.type === 'application/pdf') {
                    this.selectedPdfFile = file;
                    this.displayPdfInfo(file);
                    this.showPdfOptions();
                } else {
                    alert('è¯·é€‰æ‹©PDFæ ¼å¼çš„æ–‡ä»¶');
                }
            }

            displaySelectedFiles() {
                const container = document.getElementById('selectedFiles');
                if (!container) return;

                if (this.selectedFiles.length === 0) {
                    container.innerHTML = '<p>æš‚æ— é€‰æ‹©æ–‡ä»¶</p>';
                    return;
                }

                const html = this.selectedFiles.map((file, index) => `
                    <div class="file-item">
                        <div class="file-info">
                            <div class="file-details">
                                <h4>${file.name}</h4>
                                <p>${this.formatFileSize(file.size)}</p>
                            </div>
                        </div>
                        <button class="remove-btn" onclick="converter.removeFile(${index})">Ã—</button>
                    </div>
                `).join('');

                container.innerHTML = html;
            }

            displayPdfInfo(file) {
                const container = document.getElementById('pdfDetails');
                if (!container) return;

                const lastModified = new Date(file.lastModified).toLocaleString('zh-CN');
                
                container.innerHTML = `
                    <div class="pdf-info-item">
                        <span class="pdf-info-label">æ–‡ä»¶å:</span>
                        <span class="pdf-info-value">${file.name}</span>
                    </div>
                    <div class="pdf-info-item">
                        <span class="pdf-info-label">æ–‡ä»¶å¤§å°:</span>
                        <span class="pdf-info-value">${this.formatFileSize(file.size)}</span>
                    </div>
                    <div class="pdf-info-item">
                        <span class="pdf-info-label">ä¿®æ”¹æ—¶é—´:</span>
                        <span class="pdf-info-value">${lastModified}</span>
                    </div>
                    <div class="pdf-info-item">
                        <span class="pdf-info-label">çŠ¶æ€:</span>
                        <span class="pdf-info-value">âœ… PDFæ–‡ä»¶å·²é€‰æ‹©</span>
                    </div>
                `;
            }

            showPdfOptions() {
                const elements = ['pdfFileInfo', 'conversionOptions', 'pdfControls'];
                elements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) element.style.display = 'block';
                });
            }

            removeFile(index) {
                this.selectedFiles.splice(index, 1);
                this.displaySelectedFiles();
                this.updateConvertButton();
            }

            clearFiles() {
                this.selectedFiles = [];
                this.displaySelectedFiles();
                this.updateConvertButton();
                const fileInput = document.getElementById('fileInput');
                if (fileInput) fileInput.value = '';
            }

            clearPdfFile() {
                this.selectedPdfFile = null;
                this.selectedFormat = null;
                
                const elements = ['pdfDetails', 'pdfFileInfo', 'conversionOptions', 'pdfControls'];
                elements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        if (id === 'pdfDetails') {
                            element.innerHTML = '';
                        } else {
                            element.style.display = 'none';
                        }
                    }
                });
                
                const formatBtns = document.querySelectorAll('.format-btn');
                formatBtns.forEach(btn => btn.classList.remove('selected'));
                
                this.updatePdfConvertButton();
                const pdfFileInput = document.getElementById('pdfFileInput');
                if (pdfFileInput) pdfFileInput.value = '';
            }

            updateConvertButton() {
                const convertBtn = document.getElementById('convertBtn');
                if (convertBtn) {
                    convertBtn.disabled = this.selectedFiles.length === 0;
                }
            }

            updatePdfConvertButton() {
                const convertBtn = document.getElementById('convertFromPdfBtn');
                if (convertBtn) {
                    convertBtn.disabled = !this.selectedPdfFile || !this.selectedFormat;
                }
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
            }

            async convertToPdf() {
                if (this.selectedFiles.length === 0) return;

                const convertBtn = document.getElementById('convertBtn');
                const originalText = convertBtn.textContent;
                
                try {
                    convertBtn.textContent = 'è½¬æ¢ä¸­...';
                    convertBtn.disabled = true;

                    console.log('ğŸ”„ å¼€å§‹è½¬æ¢ä¸ºPDF...');
                    
                    if (typeof window.jspdf === 'undefined') {
                        throw new Error('jsPDFåº“æœªåŠ è½½');
                    }

                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF();
                    let isFirstPage = true;

                    for (const file of this.selectedFiles) {
                        if (!isFirstPage) {
                            pdf.addPage();
                        }
                        await this.addFileToPdf(pdf, file);
                        isFirstPage = false;
                    }

                    pdf.save('converted-files.pdf');
                    console.log('âœ… PDFè½¬æ¢å®Œæˆ');
                    
                } catch (error) {
                    console.error('âŒ è½¬æ¢å¤±è´¥:', error);
                    alert(`è½¬æ¢å¤±è´¥: ${error.message}`);
                } finally {
                    convertBtn.textContent = originalText;
                    convertBtn.disabled = false;
                }
            }

            async addFileToPdf(pdf, file) {
                const fileType = file.type;
                const fileName = file.name.toLowerCase();

                if (fileType.startsWith('image/')) {
                    await this.addImageToPdf(pdf, file);
                } else if (fileType === 'text/plain' || fileName.endsWith('.txt')) {
                    await this.addTextToPdf(pdf, file);
                } else {
                    // ç®€åŒ–å¤„ç†ï¼Œå…¶ä»–æ ¼å¼æš‚æ—¶ä½œä¸ºæ–‡æœ¬å¤„ç†
                    await this.addTextToPdf(pdf, file);
                }
            }

            async addImageToPdf(pdf, file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const img = new Image();
                            img.onload = () => {
                                const pageWidth = pdf.internal.pageSize.getWidth();
                                const pageHeight = pdf.internal.pageSize.getHeight();
                                const margin = 20;
                                
                                const maxWidth = pageWidth - 2 * margin;
                                const maxHeight = pageHeight - 2 * margin;
                                
                                let { width, height } = this.calculateImageSize(img.width, img.height, maxWidth, maxHeight);
                                
                                const x = (pageWidth - width) / 2;
                                const y = (pageHeight - height) / 2;
                                
                                pdf.addImage(e.target.result, 'JPEG', x, y, width, height);
                                resolve();
                            };
                            img.onerror = () => reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥'));
                            img.src = e.target.result;
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = () => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
                    reader.readAsDataURL(file);
                });
            }

            async addTextToPdf(pdf, file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const text = e.target.result || 'æ— æ³•è¯»å–æ–‡ä»¶å†…å®¹';
                            const lines = text.split('\n');
                            
                            pdf.setFontSize(12);
                            const pageHeight = pdf.internal.pageSize.getHeight();
                            const margin = 20;
                            const lineHeight = 7;
                            const maxLinesPerPage = Math.floor((pageHeight - 2 * margin) / lineHeight);
                            
                            let currentLine = 0;
                            let y = margin;
                            
                            // æ·»åŠ æ–‡ä»¶åä½œä¸ºæ ‡é¢˜
                            pdf.setFontSize(14);
                            pdf.text(`æ–‡ä»¶: ${file.name}`, margin, y);
                            y += lineHeight * 2;
                            pdf.setFontSize(12);
                            currentLine += 2;
                            
                            for (const line of lines) {
                                if (currentLine >= maxLinesPerPage) {
                                    pdf.addPage();
                                    y = margin;
                                    currentLine = 0;
                                }
                                
                                pdf.text(line || '', margin, y);
                                y += lineHeight;
                                currentLine++;
                            }
                            
                            resolve();
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = () => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
                    reader.readAsText(file, 'UTF-8');
                });
            }

            calculateImageSize(originalWidth, originalHeight, maxWidth, maxHeight) {
                let width = originalWidth;
                let height = originalHeight;
                
                if (width > maxWidth) {
                    height = (height * maxWidth) / width;
                    width = maxWidth;
                }
                
                if (height > maxHeight) {
                    width = (width * maxHeight) / height;
                    height = maxHeight;
                }
                
                return { width, height };
            }

            async convertPdfToFile() {
                if (!this.selectedPdfFile || !this.selectedFormat) {
                    alert('è¯·é€‰æ‹©PDFæ–‡ä»¶å’Œè¾“å‡ºæ ¼å¼');
                    return;
                }

                const convertBtn = document.getElementById('convertFromPdfBtn');
                const originalText = convertBtn.textContent;
                
                try {
                    convertBtn.textContent = 'è½¬æ¢ä¸­...';
                    convertBtn.disabled = true;

                    console.log('ğŸ”„ å¼€å§‹PDFè½¬æ¢...', this.selectedFormat);
                    const arrayBuffer = await this.selectedPdfFile.arrayBuffer();
                    
                    switch (this.selectedFormat) {
                        case 'txt':
                            await this.convertPdfToText(arrayBuffer);
                            break;
                        case 'docx':
                            await this.convertPdfToDocx(arrayBuffer);
                            break;
                        case 'xlsx':
                            await this.convertPdfToExcel(arrayBuffer);
                            break;
                        case 'png':
                        case 'jpg':
                            await this.convertPdfToImages(arrayBuffer, this.selectedFormat);
                            break;
                        default:
                            throw new Error('ä¸æ”¯æŒçš„è¾“å‡ºæ ¼å¼');
                    }
                    
                    console.log('âœ… PDFè½¬æ¢å®Œæˆ');
                    
                } catch (error) {
                    console.error('âŒ è½¬æ¢å¤±è´¥:', error);
                    alert(`è½¬æ¢å¤±è´¥: ${error.message}`);
                } finally {
                    convertBtn.textContent = originalText;
                    convertBtn.disabled = false;
                }
            }

            async convertPdfToText(arrayBuffer) {
                try {
                    if (typeof pdfjsLib === 'undefined') {
                        throw new Error('PDF.jsåº“æœªåŠ è½½');
                    }
                    
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    
                    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                    const pdf = await loadingTask.promise;
                    
                    let fullText = '';
                    
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items.map(item => item.str).join(' ');
                        fullText += `ç¬¬${i}é¡µ:\n${pageText}\n\n`;
                    }
                    
                    const blob = new Blob([fullText], { type: 'text/plain;charset=utf-8' });
                    const fileName = this.selectedPdfFile.name.replace('.pdf', '.txt');
                    this.downloadFile(blob, fileName);
                    
                } catch (error) {
                    throw new Error(`PDFè½¬æ–‡æœ¬å¤±è´¥: ${error.message}`);
                }
            }

            async convertPdfToDocx(arrayBuffer) {
                try {
                    if (typeof pdfjsLib === 'undefined') {
                        throw new Error('PDF.jsåº“æœªåŠ è½½');
                    }
                    if (typeof JSZip === 'undefined') {
                        throw new Error('JSZipåº“æœªåŠ è½½');
                    }
                    
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    
                    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                    const pdf = await loadingTask.promise;
                    
                    let allText = [];
                    
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        
                        allText.push(`=== ç¬¬${i}é¡µ ===`);
                        
                        textContent.items.forEach(item => {
                            if (item.str.trim()) {
                                allText.push(item.str.trim());
                            }
                        });
                        
                        allText.push('');
                    }
                    
                    // åˆ›å»ºDOCXæ–‡æ¡£
                    const docContent = allText.map(text => 
                        text ? `<w:p><w:r><w:t>${this.escapeXml(text)}</w:t></w:r></w:p>` : '<w:p></w:p>'
                    ).join('');
                    
                    const docXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
    <w:body>
        ${docContent}
    </w:body>
</w:document>`;
                    
                    // åˆ›å»ºZIPæ–‡ä»¶ç»“æ„
                    const zip = new JSZip();
                    
                    zip.file('[Content_Types].xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
    <Default Extension="xml" ContentType="application/xml"/>
    <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
</Types>`);
                    
                    zip.folder('_rels').file('.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>`);
                    
                    zip.folder('word').file('document.xml', docXml);
                    
                    zip.folder('word/_rels').file('document.xml.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
</Relationships>`);
                    
                    const blob = await zip.generateAsync({ type: 'blob' });
                    const fileName = this.selectedPdfFile.name.replace('.pdf', '.docx');
                    this.downloadFile(blob, fileName);
                    
                } catch (error) {
                    throw new Error(`PDFè½¬DOCXå¤±è´¥: ${error.message}`);
                }
            }

            async convertPdfToExcel(arrayBuffer) {
                try {
                    if (typeof pdfjsLib === 'undefined') {
                        throw new Error('PDF.jsåº“æœªåŠ è½½');
                    }
                    if (typeof XLSX === 'undefined') {
                        throw new Error('XLSXåº“æœªåŠ è½½');
                    }
                    
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    
                    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                    const pdf = await loadingTask.promise;
                    
                    const workbook = XLSX.utils.book_new();
                    
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        
                        const pageText = textContent.items
                            .map(item => item.str)
                            .filter(str => str.trim())
                            .join('\n');
                        
                        const worksheetData = [
                            [`ç¬¬${i}é¡µå†…å®¹`],
                            [pageText]
                        ];
                        
                        const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);
                        
                        worksheet['!cols'] = [
                            { wch: 15 },
                            { wch: 80 }
                        ];
                        
                        worksheet['!rows'] = [
                            { hpt: 20 },
                            { hpt: 200 }
                        ];
                        
                        XLSX.utils.book_append_sheet(workbook, worksheet, `ç¬¬${i}é¡µ`);
                    }
                    
                    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
                    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    const fileName = this.selectedPdfFile.name.replace('.pdf', '.xlsx');
                    this.downloadFile(blob, fileName);
                    
                } catch (error) {
                    throw new Error(`PDFè½¬Excelå¤±è´¥: ${error.message}`);
                }
            }

            async convertPdfToImages(arrayBuffer, format) {
                try {
                    if (typeof pdfjsLib === 'undefined') {
                        throw new Error('PDF.jsåº“æœªåŠ è½½');
                    }
                    
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    
                    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                    const pdf = await loadingTask.promise;
                    
                    const images = [];
                    
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const viewport = page.getViewport({ scale: 2.0 });
                        
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;
                        
                        const renderContext = {
                            canvasContext: context,
                            viewport: viewport
                        };
                        
                        await page.render(renderContext).promise;
                        
                        const imageDataUrl = canvas.toDataURL(`image/${format}`, 0.95);
                        images.push({
                            dataUrl: imageDataUrl,
                            pageNumber: i
                        });
                    }
                    
                    // å¦‚æœåªæœ‰ä¸€é¡µï¼Œç›´æ¥ä¸‹è½½
                    if (images.length === 1) {
                        const fileName = this.selectedPdfFile.name.replace('.pdf', `.${format}`);
                        this.downloadDataUrl(images[0].dataUrl, fileName);
                    } else {
                        // å¤šé¡µæ—¶åˆ›å»ºZIPæ–‡ä»¶
                        if (typeof JSZip === 'undefined') {
                            throw new Error('JSZipåº“æœªåŠ è½½ï¼Œæ— æ³•æ‰“åŒ…å¤šé¡µå›¾ç‰‡');
                        }
                        
                        const zip = new JSZip();
                        const baseName = this.selectedPdfFile.name.replace('.pdf', '');
                        
                        images.forEach(img => {
                            const fileName = `${baseName}_ç¬¬${img.pageNumber}é¡µ.${format}`;
                            const base64Data = img.dataUrl.split(',')[1];
                            zip.file(fileName, base64Data, { base64: true });
                        });
                        
                        const zipBlob = await zip.generateAsync({ type: 'blob' });
                        this.downloadFile(zipBlob, `${baseName}_å›¾ç‰‡.zip`);
                    }
                    
                } catch (error) {
                    throw new Error(`PDFè½¬å›¾ç‰‡å¤±è´¥: ${error.message}`);
                }
            }

            escapeXml(text) {
                return text
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;');
            }

            downloadFile(blob, fileName) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            downloadDataUrl(dataUrl, fileName) {
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
        }

        // åˆ›å»ºå…¨å±€å®ä¾‹
        let converter;
        
        // ç¡®ä¿åœ¨é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                converter = new SimpleFileConverter();
            });
        } else {
            converter = new SimpleFileConverter();
        }
    </script>
</body>
</html>